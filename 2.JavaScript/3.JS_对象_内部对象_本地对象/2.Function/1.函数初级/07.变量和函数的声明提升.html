<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>声明提升</title>
    <script>
        /* --声明提升:只有var和function开头的代码会被提升。
         *
         * -变量的声明提升
         * 	 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），
         *      但是如果声明变量时不使用var关键字，则变量不会被声明提前.
         *   使用let声明的变量无法在初始化前被访问
         *
         * -函数的声明提升
         * 	 使用函数声明形式创建的函数 function 函数(){};它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数.
         * 	 使用函数表达式创建的函数，只会提升变量，不会提升函数,所以不能在声明前调用.
         *   在函数作用域也有声明提前的特性，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明
         *      结论:使用函数声明的形式（function xxx）创建函数，它会在所有的代码执行前被创建,所以可以在函数声明前就对其进行调用
         */

        /* 变量的提升
            console.log("a = " + a);
            var a = 123;
            相当于:
                 var a;
                 console.log("a = " + a); //a = undefined
                 a = 123;
        */

        /* 函数声明，会被提前创建
            fun();
            function fun() {
                console.log("我是一个fun函数");
            }
            相当于:
                 function fun() {
                     console.log("我是一个fun函数");
                 }
                 fun();
         */


        //使用函数表达式创建的函数，只会提示变量，不会提示函数,所以不能在声明前调用
        var fun2 = function () {
            console.log("我是fun2函数");
        };
        fun2();


        //在函数中，不使用var声明的变量都会成为全局变量
        var c = 33;
        function fun5() {
            d = 100;
            console.log("c = " + c);
            c = 10;
        }
        fun5();//c = 33
        console.log("d = " + d);// d = 100;


        //定义形参就相当于在函数作用域中声明了变量
        var e = 23;
        function fun6(e) {
            console.log(e);
        }
        fun6();// undefined
    </script>
</head>
<body>
</body>
</html>
